// サンキーダイアグラム作成ツール
class SankeyDiagramTool {
    constructor() {
        this.links = [];
        this.chartData = null;
        this.nodeColors = new Map();
        this.unit = '円'; // 単位を管理

        this.initializeEventListeners();
        this.loadSampleData();
    }

    initializeEventListeners() {
        // テキスト入力のリアルタイム更新
        document.getElementById('text-data').addEventListener('input', () => {
            this.parseTextData();
            this.autoGenerateDiagram();
        });

        // 単位入力の変更
        document.getElementById('unit-field').addEventListener('input', (e) => {
            this.unit = e.target.value.trim() || '';
            this.autoGenerateDiagram();
        });


    }

    loadSampleData() {
        // 単位フィールドから初期値を読み込み
        const unitField = document.getElementById('unit-field');
        if (unitField) {
            this.unit = unitField.value.trim() || '';
        }

        // HTMLのplaceholder属性からサンプルデータを読み込み
        const textArea = document.getElementById('text-data');
        const sampleText = textArea.placeholder || '';

        // テキストエリアにサンプルデータを設定
        textArea.value = sampleText;
        this.parseTextData();

        // 初期ダイアグラムを生成（DOMの描画完了を待つ）
        setTimeout(() => {
            this.generateDiagram();
        }, 500);
    }

    parseTextData() {
        const textData = document.getElementById('text-data').value.trim();
        const lines = textData.split('\n');
        const parsedLinks = [];

        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine.startsWith('//')) return;

            // パターン: "ソース [値] ターゲット" または "ソース ［値］ ターゲット"
            const match = trimmedLine.match(/^(.+?)\s*[\[［](\d+(?:\.\d+)?)[\]］]\s*(.+)$/);

            if (match) {
                const [, source, value, target] = match;
                const numValue = parseFloat(value);

                if (source.trim() && target.trim() && !isNaN(numValue) && numValue > 0) {
                    parsedLinks.push({
                        id: Date.now() + index,
                        source: source.trim(),
                        target: target.trim(),
                        value: numValue
                    });
                }
            }
        });

        this.links = parsedLinks;
        this.assignNodeColors();
        console.log('Parsed links:', this.links);
    }

    generatePastelColor(index) {
        // 黒文字・グレー文字が見やすい適度に明るいブルー〜グリーン系パレット
        const balancedBlueGreenColors = [
            '#D4E6F1', // ライトブルー（適度に濃い）
            '#BBDEFB', // ライトブルー
            '#90CAF9', // ミディアムライトブルー
            '#64B5F6', // ミディアムブルー
            '#D1F2EB', // ライトシアン（適度に濃い）
            '#B2EBF2', // ベリライトシアン
            '#80DEEA', // ライトシアン
            '#4DD0E1', // ミディアムライトシアン
            '#D1F2EB', // ライトティール（適度に濃い）
            '#B2DFDB', // ライトティール
            '#80CBC4', // ミディアムライトティール
            '#4DB6AC'  // ミディアムティール
        ];

        return balancedBlueGreenColors[index % balancedBlueGreenColors.length];
    }

    assignNodeColors() {
        // 全ノードを抽出
        const nodeSet = new Set();
        this.links.forEach(link => {
            nodeSet.add(link.source);
            nodeSet.add(link.target);
        });

        // 各ノードにパステルカラーを割り当て
        Array.from(nodeSet).forEach((nodeName, index) => {
            this.nodeColors.set(nodeName, this.generatePastelColor(index));
        });

        console.log('Node colors assigned:', this.nodeColors);
    }

    formatNumber(num) {
        const formattedNum = num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return this.unit ? `${formattedNum}${this.unit}` : formattedNum;
    }

    editNodeLabel(event, nodeData) {
        const groupElement = event.currentTarget;
        const currentName = nodeData.name;

        // グループ全体を一時的に隠す
        groupElement.style.display = 'none';

        // グループの位置を取得
        const nameText = groupElement.querySelector('.node-name');
        const isLeftSide = nameText.getAttribute('text-anchor') === 'start';
        const x = parseFloat(nameText.getAttribute('x'));
        const y = parseFloat(nameText.getAttribute('y'));

        // 編集用のコンテナを作成
        const foreignObject = d3.select(groupElement.parentNode)
            .append('foreignObject')
            .attr('x', isLeftSide ? x - 5 : x - 120)
            .attr('y', y - 12)
            .attr('width', 120)
            .attr('height', 24);

        // 名前入力フィールド（シンプル版）
        const input = foreignObject
            .append('xhtml:input')
            .attr('type', 'text')
            .attr('value', currentName)
            .style('width', '100%')
            .style('height', '100%')
            .style('border', '1px solid #4285f4')
            .style('border-radius', '4px')
            .style('padding', '2px 6px')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .style('outline', 'none')
            .style('box-shadow', '0 2px 8px rgba(0,0,0,0.1)');

        // フォーカスを設定してテキストを選択
        input.node().focus();
        input.node().select();

        // 編集完了時の処理
        const finishEdit = () => {
            const newName = input.node().value.trim();
            foreignObject.remove();
            groupElement.style.display = 'block';

            if (newName && newName !== currentName) {
                this.updateNodeName(currentName, newName);
            }
        };

        // イベントリスナー
        input.on('blur', finishEdit);
        input.on('keydown', (event) => {
            if (event.key === 'Enter') {
                finishEdit();
            } else if (event.key === 'Escape') {
                foreignObject.remove();
                groupElement.style.display = 'block';
            }
        });
    }

    editNodeValue(event, nodeData) {
        const textElement = event.target;
        const currentName = nodeData.name;
        const currentValue = nodeData.value;

        // テキスト要素を一時的に隠す
        textElement.style.display = 'none';

        // 位置情報を取得
        const isLeftSide = textElement.getAttribute('text-anchor') === 'start';
        const x = parseFloat(textElement.getAttribute('x'));
        const y = parseFloat(textElement.getAttribute('y'));

        // 編集用のコンテナを作成
        const foreignObject = d3.select(textElement.parentNode.parentNode)
            .append('foreignObject')
            .attr('x', isLeftSide ? x - 5 : x - 85)
            .attr('y', y - 12)
            .attr('width', 90)
            .attr('height', 24);

        const container = foreignObject
            .append('xhtml:div')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('background', 'white')
            .style('border', '1px solid #4285f4')
            .style('border-radius', '4px')
            .style('padding', '2px')
            .style('font-size', '12px')
            .style('box-shadow', '0 2px 8px rgba(0,0,0,0.1)');

        // 数値入力フィールド
        const input = container
            .append('xhtml:input')
            .attr('type', 'number')
            .attr('value', currentValue)
            .attr('min', '0')
            .attr('step', '1')
            .style('border', 'none')
            .style('outline', 'none')
            .style('padding', '2px 4px')
            .style('font-size', '12px')
            .style('width', '60px')
            .style('text-align', 'right')
            .style('-webkit-appearance', 'none')
            .style('-moz-appearance', 'textfield');

        // WebKit系ブラウザの矢印を完全に削除
        const inputElement = input.node();
        const style = document.createElement('style');
        style.textContent = `
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: none !important;
                margin: 0 !important;
            }
        `;
        document.head.appendChild(style);

        // 単位表示
        if (this.unit) {
            container
                .append('xhtml:span')
                .text(this.unit)
                .style('color', '#666')
                .style('margin-left', '2px')
                .style('font-size', '12px');
        }

        // フォーカスを設定してテキストを選択
        input.node().focus();
        input.node().select();

        // 編集完了時の処理
        const finishEdit = () => {
            const newValue = parseFloat(input.node().value);
            foreignObject.remove();
            textElement.style.display = 'block';

            if (!isNaN(newValue) && newValue > 0 && newValue !== currentValue) {
                this.updateNodeValue(currentName, newValue);
            }
        };

        // イベントリスナー
        input.on('blur', finishEdit);
        input.on('keydown', (event) => {
            if (event.key === 'Enter') {
                finishEdit();
            } else if (event.key === 'Escape') {
                foreignObject.remove();
                textElement.style.display = 'block';
            }
        });
    }

    updateNodeName(oldName, newName) {
        // リンクデータ内のノード名を更新
        this.links.forEach(link => {
            if (link.source === oldName) {
                link.source = newName;
            }
            if (link.target === oldName) {
                link.target = newName;
            }
        });

        // 色のマッピングを更新
        if (this.nodeColors.has(oldName)) {
            const color = this.nodeColors.get(oldName);
            this.nodeColors.delete(oldName);
            this.nodeColors.set(newName, color);
        }

        // テキストエリアを更新
        this.updateTextDataFromLinks();

        // ダイアグラムを再生成
        this.autoGenerateDiagram();

        console.log(`Node name changed: ${oldName} → ${newName}`);
    }

    updateNodeValue(nodeName, newValue) {
        // 指定されたノードを含むリンクデータの値を更新
        this.links.forEach(link => {
            if (link.source === nodeName || link.target === nodeName) {
                // ソースノードの場合は出力値を更新
                if (link.source === nodeName) {
                    link.value = newValue;
                }
            }
        });

        // テキストエリアを更新
        this.updateTextDataFromLinks();

        // ダイアグラムを再生成
        this.autoGenerateDiagram();

        console.log(`Node value changed: ${nodeName} → ${newValue}`);
    }

    updateTextDataFromLinks() {
        const textLines = this.links.map(link =>
            `${link.source} [${link.value}] ${link.target}`
        );
        document.getElementById('text-data').value = textLines.join('\n');
    }

    autoGenerateDiagram() {
        if (this.links.length > 0) {
            // より即座に反応するように遅延時間を短縮
            clearTimeout(this.updateTimeout);
            this.updateTimeout = setTimeout(() => {
                this.generateDiagram();
            }, 200); // 0.2秒の遅延でリアルタイム更新
        } else {
            // データがない場合はプレースホルダーを表示
            document.getElementById('chart-placeholder').classList.remove('hidden');
            document.getElementById('sankey-chart').classList.remove('active');
        }
    }

    prepareChartData() {
        if (!this.links || this.links.length === 0) {
            alert('有効なデータがありません');
            return null;
        }

        // ノードを抽出
        const nodeSet = new Set();
        this.links.forEach(link => {
            nodeSet.add(link.source);
            nodeSet.add(link.target);
        });

        const nodes = Array.from(nodeSet).map(name => ({ name }));

        // ノード名からインデックスへのマップを作成
        const nodeIndexMap = new Map();
        nodes.forEach((node, index) => {
            nodeIndexMap.set(node.name, index);
        });

        // リンクのsource/targetをインデックスに変換
        const links = this.links.map(link => ({
            source: nodeIndexMap.get(link.source),
            target: nodeIndexMap.get(link.target),
            value: link.value
        }));

        console.log('Nodes:', nodes);
        console.log('Links with indices:', links);

        return { nodes, links };
    }

    generateDiagram() {
        console.log('generateDiagram called');
        console.log('Current links:', this.links);

        this.chartData = this.prepareChartData();
        console.log('Prepared chart data:', this.chartData);

        if (!this.chartData) return;

        this.createSankeyChart(this.chartData);

        // プレースホルダーを隠してチャートを表示
        document.getElementById('chart-placeholder').classList.add('hidden');
        document.getElementById('sankey-chart').classList.add('active');

        console.log('Chart should be visible now');
    }

    createSankeyChart(data) {
        try {
            console.log('createSankeyChart called with data:', data);

            const chartContainer = document.getElementById('sankey-chart');
            if (!chartContainer) {
                console.error('Chart container not found');
                return;
            }

            chartContainer.innerHTML = '';

            // コンテナサイズを取得（複数の方法で試行）
            let containerWidth = chartContainer.clientWidth || chartContainer.offsetWidth;
            let containerHeight = chartContainer.clientHeight || chartContainer.offsetHeight;

            // サイズが取得できない場合はデフォルト値を使用
            if (containerWidth === 0) containerWidth = 960;
            if (containerHeight === 0) containerHeight = 880;

            const margin = { top: 10, right: 60, bottom: 10, left: 60 };
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            console.log('Chart dimensions:', {
                width,
                height,
                containerWidth,
                containerHeight,
                clientWidth: chartContainer.clientWidth,
                clientHeight: chartContainer.clientHeight,
                offsetWidth: chartContainer.offsetWidth,
                offsetHeight: chartContainer.offsetHeight
            });

            // より柔軟な最小サイズチェック
            if (width < 100 || height < 100) {
                console.error('Chart container too small:', { width, height });
                // アラートの代わりにコンソールエラーのみ出力
                console.warn('Using minimum chart size instead');
                // 最小サイズを強制設定
                containerWidth = Math.max(containerWidth, 400);
                containerHeight = Math.max(containerHeight, 300);
            }

            const svg = d3.select('#sankey-chart')
                .append('svg')
                .attr('width', containerWidth)
                .attr('height', containerHeight);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // サンキーレイアウトを作成
            const sankey = d3.sankey()
                .nodeWidth(15)
                .nodePadding(10)
                .extent([[0, 0], [width, height]]);

            // サンキーデータを準備
            const sankeyData = {
                nodes: data.nodes.map(d => Object.assign({}, d)),
                links: data.links.map(d => Object.assign({}, d))
            };

            console.log('Sankey input data:', sankeyData);

            const sankeyResult = sankey(sankeyData);
            const { nodes, links } = sankeyResult;

            console.log('Sankey result:', { nodes, links });

            // リンクを描画（ソースノードの色を使用）
            g.append('g')
                .selectAll('path')
                .data(links)
                .enter().append('path')
                .attr('class', 'sankey-link')
                .attr('d', d3.sankeyLinkHorizontal())
                .attr('stroke', d => this.nodeColors.get(d.source.name) || '#cccccc')
                .attr('stroke-width', d => Math.max(1, d.width))
                .attr('stroke-opacity', 0.6)
                .attr('fill', 'none')
                .append('title')
                .text(d => `${d.source.name} → ${d.target.name}\n値: ${this.formatNumber(d.value)}`);

            // ノードを描画
            const node = g.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'sankey-node');

            node.append('rect')
                .attr('x', d => d.x0)
                .attr('y', d => d.y0)
                .attr('height', d => Math.max(0, d.y1 - d.y0))
                .attr('width', d => Math.max(0, d.x1 - d.x0))
                .attr('fill', d => this.nodeColors.get(d.name) || '#cccccc')
                .append('title')
                .text(d => `${d.name}\n値: ${this.formatNumber(d.value)}`);

            // ノードのラベル（編集可能）
            const nodeGroups = node.append('g')
                .attr('class', 'node-label-group')
                .style('cursor', 'pointer');

            // ノード名（1行目）
            const nameLabels = nodeGroups.append('text')
                .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr('y', d => (d.y1 + d.y0) / 2 - 8)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
                .text(d => d.name)
                .attr('class', 'node-label node-name')
                .style('user-select', 'none');

            // 値（2行目）
            const valueLabels = nodeGroups.append('text')
                .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr('y', d => (d.y1 + d.y0) / 2 + 8)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
                .text(d => this.formatNumber(d.value))
                .attr('class', 'node-label node-value')
                .style('user-select', 'none')
                .style('fill', '#666')
                .style('cursor', 'pointer')
                .on('click', (event, d) => {
                    event.stopPropagation(); // 親のクリックイベントを防ぐ
                    this.editNodeValue(event, d);
                });

            // クリックイベントをグループ全体に設定（ノード名編集用）
            nodeGroups.on('click', (event, d) => {
                this.editNodeLabel(event, d);
            });

            console.log('Chart created successfully');
        } catch (error) {
            console.error('Error creating sankey chart:', error);
            alert('ダイアグラムの作成中にエラーが発生しました: ' + error.message);
        }
    }


}

// DOMが読み込まれた後にアプリケーションを初期化
document.addEventListener('DOMContentLoaded', () => {
    // D3.jsが正しく読み込まれているかチェック
    if (typeof d3 === 'undefined') {
        alert('D3.jsライブラリが読み込まれていません。インターネット接続を確認してください。');
        return;
    }

    if (typeof d3.sankey === 'undefined') {
        alert('d3-sankeyライブラリが読み込まれていません。インターネット接続を確認してください。');
        return;
    }

    console.log('D3.js libraries loaded successfully');

    const tool = new SankeyDiagramTool();

    // グローバル変数として設定（削除ボタンのonclick用）
    window.tool = tool;
});
