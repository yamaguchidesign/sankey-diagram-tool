// サンキーダイアグラム作成ツール
class SankeyDiagramTool {
    constructor() {
        this.links = [];
        this.chartData = null;
        this.nodeColors = new Map();
        this.unit = '円'; // 単位を管理

        this.initializeEventListeners();
        this.loadSampleData();
    }

    initializeEventListeners() {
        // テキスト入力のリアルタイム更新
        document.getElementById('text-data').addEventListener('input', () => {
            this.parseTextData();
            this.autoGenerateDiagram();
        });

        // 単位入力の変更
        document.getElementById('unit-field').addEventListener('input', (e) => {
            this.unit = e.target.value.trim() || '';
            this.autoGenerateDiagram();
        });

        // アクション
        document.getElementById('export-btn').addEventListener('click', () => {
            this.exportSVG();
        });
    }

    loadSampleData() {
        // 単位フィールドから初期値を読み込み
        const unitField = document.getElementById('unit-field');
        if (unitField) {
            this.unit = unitField.value.trim() || '';
        }

        // サンプルデータをテキストエリアに設定
        const sampleText = `Web広告 [1000] サイト訪問
検索エンジン [800] サイト訪問
SNS [600] サイト訪問
サイト訪問 [1200] 商品閲覧
サイト訪問 [1200] 離脱
商品閲覧 [400] カート追加
商品閲覧 [800] 離脱
カート追加 [300] 購入完了
カート追加 [100] 離脱`;

        document.getElementById('text-data').value = sampleText;
        this.parseTextData();

        // 初期ダイアグラムを生成（DOMの描画完了を待つ）
        setTimeout(() => {
            this.generateDiagram();
        }, 500);
    }

    parseTextData() {
        const textData = document.getElementById('text-data').value.trim();
        const lines = textData.split('\n');
        const parsedLinks = [];

        lines.forEach((line, index) => {
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine.startsWith('//')) return;

            // パターン: "ソース [値] ターゲット" または "ソース ［値］ ターゲット"
            const match = trimmedLine.match(/^(.+?)\s*[\[［](\d+(?:\.\d+)?)[\]］]\s*(.+)$/);

            if (match) {
                const [, source, value, target] = match;
                const numValue = parseFloat(value);

                if (source.trim() && target.trim() && !isNaN(numValue) && numValue > 0) {
                    parsedLinks.push({
                        id: Date.now() + index,
                        source: source.trim(),
                        target: target.trim(),
                        value: numValue
                    });
                }
            }
        });

        this.links = parsedLinks;
        this.assignNodeColors();
        console.log('Parsed links:', this.links);
    }

    generatePastelColor(index) {
        // 美しいパステルカラーのパレット
        const pastelColors = [
            '#FFB6C1', // ライトピンク
            '#98FB98', // ペールグリーン
            '#87CEEB', // スカイブルー
            '#DDA0DD', // プラム
            '#F0E68C', // カーキ
            '#FFE4B5', // モカシン
            '#B0E0E6', // パウダーブルー
            '#F5DEB3', // ウィート
            '#FFC0CB', // ピンク
            '#AFEEEE', // ペールターコイズ
            '#D8BFD8', // シスル
            '#FFEFD5', // パパイヤホイップ
            '#E0E6FF', // ライトブルー
            '#FFE4E1', // ミスティローズ
            '#F0FFF0', // ハニーデュー
            '#FDF5E6', // オールドレース
            '#E6E6FA', // ラベンダー
            '#FFF8DC', // コーンシルク
            '#F5F5DC', // ベージュ
            '#FAFAD2'  // ライトゴールデンロッド
        ];

        return pastelColors[index % pastelColors.length];
    }

    assignNodeColors() {
        // 全ノードを抽出
        const nodeSet = new Set();
        this.links.forEach(link => {
            nodeSet.add(link.source);
            nodeSet.add(link.target);
        });

        // 各ノードにパステルカラーを割り当て
        Array.from(nodeSet).forEach((nodeName, index) => {
            this.nodeColors.set(nodeName, this.generatePastelColor(index));
        });

        console.log('Node colors assigned:', this.nodeColors);
    }

    formatNumber(num) {
        const formattedNum = num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return this.unit ? `${formattedNum}${this.unit}` : formattedNum;
    }

    editNodeLabel(event, nodeData) {
        const groupElement = event.currentTarget;
        const currentName = nodeData.name;
        const currentValue = nodeData.value;

        // グループ全体を一時的に隠す
        groupElement.style.display = 'none';

        // グループの位置を取得
        const nameText = groupElement.querySelector('.node-name');
        const isLeftSide = nameText.getAttribute('text-anchor') === 'start';
        const x = parseFloat(nameText.getAttribute('x'));
        const y = parseFloat(nameText.getAttribute('y'));

        // 編集用のコンテナを作成
        const foreignObject = d3.select(groupElement.parentNode)
            .append('foreignObject')
            .attr('x', isLeftSide ? x - 5 : x - 135)
            .attr('y', y - 15)
            .attr('width', 140)
            .attr('height', 50);

        const container = foreignObject
            .append('xhtml:div')
            .style('display', 'flex')
            .style('flex-direction', 'column')
            .style('background', 'white')
            .style('border', '1px solid #4285f4')
            .style('border-radius', '4px')
            .style('padding', '4px')
            .style('font-size', '14px')
            .style('box-shadow', '0 2px 8px rgba(0,0,0,0.1)');

        // 名前入力フィールド
        const input = container
            .append('xhtml:input')
            .attr('type', 'text')
            .attr('value', currentName)
            .style('border', 'none')
            .style('outline', 'none')
            .style('padding', '2px 4px')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .style('margin-bottom', '2px');

        // 値表示（読み取り専用）
        container
            .append('xhtml:div')
            .text(this.formatNumber(currentValue))
            .style('color', '#666')
            .style('font-size', '14px')
            .style('padding', '2px 4px')
            .style('text-align', isLeftSide ? 'left' : 'right');

        // フォーカスを設定してテキストを選択
        input.node().focus();
        input.node().select();

        // 編集完了時の処理
        const finishEdit = () => {
            const newName = input.node().value.trim();
            foreignObject.remove();
            groupElement.style.display = 'block';

            if (newName && newName !== currentName) {
                this.updateNodeName(currentName, newName);
            }
        };

        // イベントリスナー
        input.on('blur', finishEdit);
        input.on('keydown', (event) => {
            if (event.key === 'Enter') {
                finishEdit();
            } else if (event.key === 'Escape') {
                foreignObject.remove();
                groupElement.style.display = 'block';
            }
        });
    }

    updateNodeName(oldName, newName) {
        // リンクデータ内のノード名を更新
        this.links.forEach(link => {
            if (link.source === oldName) {
                link.source = newName;
            }
            if (link.target === oldName) {
                link.target = newName;
            }
        });

        // 色のマッピングを更新
        if (this.nodeColors.has(oldName)) {
            const color = this.nodeColors.get(oldName);
            this.nodeColors.delete(oldName);
            this.nodeColors.set(newName, color);
        }

        // テキストエリアを更新
        this.updateTextDataFromLinks();

        // ダイアグラムを再生成
        this.autoGenerateDiagram();

        console.log(`Node name changed: ${oldName} → ${newName}`);
    }

    updateTextDataFromLinks() {
        const textLines = this.links.map(link =>
            `${link.source} [${link.value}] ${link.target}`
        );
        document.getElementById('text-data').value = textLines.join('\n');
    }

    autoGenerateDiagram() {
        if (this.links.length > 0) {
            // より即座に反応するように遅延時間を短縮
            clearTimeout(this.updateTimeout);
            this.updateTimeout = setTimeout(() => {
                this.generateDiagram();
            }, 200); // 0.2秒の遅延でリアルタイム更新
        } else {
            // データがない場合はプレースホルダーを表示
            document.getElementById('chart-placeholder').classList.remove('hidden');
            document.getElementById('sankey-chart').classList.remove('active');
        }
    }

    prepareChartData() {
        if (!this.links || this.links.length === 0) {
            alert('有効なデータがありません');
            return null;
        }

        // ノードを抽出
        const nodeSet = new Set();
        this.links.forEach(link => {
            nodeSet.add(link.source);
            nodeSet.add(link.target);
        });

        const nodes = Array.from(nodeSet).map(name => ({ name }));

        // ノード名からインデックスへのマップを作成
        const nodeIndexMap = new Map();
        nodes.forEach((node, index) => {
            nodeIndexMap.set(node.name, index);
        });

        // リンクのsource/targetをインデックスに変換
        const links = this.links.map(link => ({
            source: nodeIndexMap.get(link.source),
            target: nodeIndexMap.get(link.target),
            value: link.value
        }));

        console.log('Nodes:', nodes);
        console.log('Links with indices:', links);

        return { nodes, links };
    }

    generateDiagram() {
        console.log('generateDiagram called');
        console.log('Current links:', this.links);

        this.chartData = this.prepareChartData();
        console.log('Prepared chart data:', this.chartData);

        if (!this.chartData) return;

        this.createSankeyChart(this.chartData);

        // プレースホルダーを隠してチャートを表示
        document.getElementById('chart-placeholder').classList.add('hidden');
        document.getElementById('sankey-chart').classList.add('active');

        console.log('Chart should be visible now');
    }

    createSankeyChart(data) {
        try {
            console.log('createSankeyChart called with data:', data);

            const chartContainer = document.getElementById('sankey-chart');
            if (!chartContainer) {
                console.error('Chart container not found');
                return;
            }

            chartContainer.innerHTML = '';

            // コンテナサイズを取得（複数の方法で試行）
            let containerWidth = chartContainer.clientWidth || chartContainer.offsetWidth;
            let containerHeight = chartContainer.clientHeight || chartContainer.offsetHeight;

            // サイズが取得できない場合はデフォルト値を使用
            if (containerWidth === 0) containerWidth = 800;
            if (containerHeight === 0) containerHeight = 600;

            const margin = { top: 10, right: 60, bottom: 10, left: 60 };
            const width = containerWidth - margin.left - margin.right;
            const height = containerHeight - margin.top - margin.bottom;

            console.log('Chart dimensions:', {
                width,
                height,
                containerWidth,
                containerHeight,
                clientWidth: chartContainer.clientWidth,
                clientHeight: chartContainer.clientHeight,
                offsetWidth: chartContainer.offsetWidth,
                offsetHeight: chartContainer.offsetHeight
            });

            // より柔軟な最小サイズチェック
            if (width < 100 || height < 100) {
                console.error('Chart container too small:', { width, height });
                // アラートの代わりにコンソールエラーのみ出力
                console.warn('Using minimum chart size instead');
                // 最小サイズを強制設定
                containerWidth = Math.max(containerWidth, 400);
                containerHeight = Math.max(containerHeight, 300);
            }

            const svg = d3.select('#sankey-chart')
                .append('svg')
                .attr('width', containerWidth)
                .attr('height', containerHeight);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // サンキーレイアウトを作成
            const sankey = d3.sankey()
                .nodeWidth(15)
                .nodePadding(10)
                .extent([[0, 0], [width, height]]);

            // サンキーデータを準備
            const sankeyData = {
                nodes: data.nodes.map(d => Object.assign({}, d)),
                links: data.links.map(d => Object.assign({}, d))
            };

            console.log('Sankey input data:', sankeyData);

            const sankeyResult = sankey(sankeyData);
            const { nodes, links } = sankeyResult;

            console.log('Sankey result:', { nodes, links });

            // リンクを描画（ソースノードの色を使用）
            g.append('g')
                .selectAll('path')
                .data(links)
                .enter().append('path')
                .attr('class', 'sankey-link')
                .attr('d', d3.sankeyLinkHorizontal())
                .attr('stroke', d => this.nodeColors.get(d.source.name) || '#cccccc')
                .attr('stroke-width', d => Math.max(1, d.width))
                .attr('stroke-opacity', 0.6)
                .attr('fill', 'none')
                .append('title')
                .text(d => `${d.source.name} → ${d.target.name}\n値: ${this.formatNumber(d.value)}`);

            // ノードを描画
            const node = g.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'sankey-node');

            node.append('rect')
                .attr('x', d => d.x0)
                .attr('y', d => d.y0)
                .attr('height', d => Math.max(0, d.y1 - d.y0))
                .attr('width', d => Math.max(0, d.x1 - d.x0))
                .attr('fill', d => this.nodeColors.get(d.name) || '#cccccc')
                .append('title')
                .text(d => `${d.name}\n値: ${this.formatNumber(d.value)}`);

            // ノードのラベル（編集可能）
            const nodeGroups = node.append('g')
                .attr('class', 'node-label-group')
                .style('cursor', 'pointer');

            // ノード名（1行目）
            const nameLabels = nodeGroups.append('text')
                .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr('y', d => (d.y1 + d.y0) / 2 - 8)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
                .text(d => d.name)
                .attr('class', 'node-label node-name')
                .style('user-select', 'none');

            // 値（2行目）
            const valueLabels = nodeGroups.append('text')
                .attr('x', d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr('y', d => (d.y1 + d.y0) / 2 + 8)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.x0 < width / 2 ? 'start' : 'end')
                .text(d => this.formatNumber(d.value))
                .attr('class', 'node-label node-value')
                .style('user-select', 'none')
                .style('fill', '#666');

            // クリックイベントをグループ全体に設定
            nodeGroups.on('click', (event, d) => {
                this.editNodeLabel(event, d);
            });

            console.log('Chart created successfully');
        } catch (error) {
            console.error('Error creating sankey chart:', error);
            alert('ダイアグラムの作成中にエラーが発生しました: ' + error.message);
        }
    }

    exportSVG() {
        const svg = document.querySelector('#sankey-chart svg');
        if (!svg) {
            alert('エクスポートするダイアグラムがありません');
            return;
        }

        const svgData = new XMLSerializer().serializeToString(svg);
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
        const svgUrl = URL.createObjectURL(svgBlob);

        const downloadLink = document.createElement('a');
        downloadLink.href = svgUrl;
        downloadLink.download = 'sankey-diagram.svg';
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        URL.revokeObjectURL(svgUrl);
    }
}

// DOMが読み込まれた後にアプリケーションを初期化
document.addEventListener('DOMContentLoaded', () => {
    // D3.jsが正しく読み込まれているかチェック
    if (typeof d3 === 'undefined') {
        alert('D3.jsライブラリが読み込まれていません。インターネット接続を確認してください。');
        return;
    }

    if (typeof d3.sankey === 'undefined') {
        alert('d3-sankeyライブラリが読み込まれていません。インターネット接続を確認してください。');
        return;
    }

    console.log('D3.js libraries loaded successfully');

    const tool = new SankeyDiagramTool();

    // グローバル変数として設定（削除ボタンのonclick用）
    window.tool = tool;
}); 